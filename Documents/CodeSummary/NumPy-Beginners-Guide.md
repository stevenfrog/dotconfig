### @python @numpy ==================================================================
# Python数据分析基础教程：NumPy学习指南（第2版）.pdf

# 第9章 怎么用Matplotlib绘图

-----
### @numpy @type ==================================================================
## Numpy数据类型

|类型      |描述|
|------   |----|
|bool     | 用一位存储的布尔类型(值为TRUE或FALSE)
|inti     | 由所在平台决定其精度的整数(一般为int32或int64)
|int8     | 整数,范围为-128至127
|int16    | 整数,范围为-32768至32767
|int32    | 整数,范围为-2^31至2^31-1
|int64    | 整数,范围为-2^63至2^63-1
|uint8    | 无符号整数,范围为0至255
|uint16   | 无符号整数,范围为0至65535
|uint32   | 无符号整数,范围为0至2^32-1
|uint64   | 无符号整数,范围为0至2^64-1
|float16              | 半精度浮点数(16位):其中用1位表示正负号,5位表示指数,10位表示尾数
|float32              | 单精度浮点数(32位):其中用1位表示正负号,8位表示指数,23位表示尾数
|float64或float       | 双精度浮点数(64位):其中用1位表示正负号,11位表示指数,52位表示尾数
|complex64            | 复数,分别用两个32位浮点数表示实部和虚部
|complex128或complex  | 复数,分别用两个64位浮点数表示实部和虚部

-----
### @numpy @选取 ==================================================================
## 选取Item
## 我们可以用三维坐标来选定任意一个房间,即楼层、行号和列号

    * b[0,0,0] -> 0
                选定第1层楼、第1行、第1列的房间(也可以说是第0层楼、第0行、第0列,这只是习惯问题)
    * b[:,0,0] -> [0, 2]
                选取所有楼层的第1行、第1列的房间
    * b[0,:,:] -> [[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9,10,11]]
                选取第一楼层的所有行、所有的房间
    * b[0,...] -> [[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9,10,11]]
                同上
    * b[0,1]   -> [ 4, 5, 6, 7]
                选取第1层楼、第2排的所有房间
    * b[0,1,::2] -> [ 4, 6]
                在上面的数组切片中间隔地选定元素
    * b[...,1] -> [[ 1, 5, 9], [13, 17, 21]]
                选取所有楼层的位于第2列的房间
    * b[:,1]   -> [[ 4, 5, 6, 7], [16, 17, 18, 19]]
                选取所有位于第2行的房间
    * b[0,:,1] -> [ 1, 5, 9]
                选取第1层楼的所有位于第2列的房间
    * b[0,:,-1] -> [ 3, 7, 11]
                选取第1层楼的最后一列的所有房间
    * b[0,::-1,1] -> [11, 7, 3]
                反向选取第1层楼的最后一列的所有房间
    * b[::-1] -> [[[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]], [[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9,10,11]]],
                最前面的维度上翻转元素的顺序, 把第1层楼和第2层楼的房间交换

-----
### @numpy @属性 ==================================================================
## 数组属性
`ndim` 数组的维数
`size` 数组元素的总个数
`itemsize` 数组中的元素在内存中所占的字节数
`nbytes` 整个数组所占的存储空间,这个属性的值其实就是itemsize和size属性值的乘积
`T` T属性的效果和transpose函数一样, 对于一维数组不变
`I` 逆矩阵
`flat` flat属性将返回一个numpy.flatiter对象
       这个所谓的“扁平迭代器”可以让我们像遍历一维数组一样去遍历任意的多维数组

>a = np.arange(6).reshape(2,3)
[[0 1 2]
 [3 4 5]]
a.ndim: 2
a.size: 6
a.itemsize: 8
a.nbytes: 48
a.T: [[0 3]
 [1 4]
 [2 5]]
a.flat[2]: 2
a.flat[3]: 3

## 复数数组属性
`real` 复数数组的实部
`imag` 复数数组的虚部
>[ 1.+1.j  3.+2.j]
b.real: [ 1.  3.]
b.imag: [ 1.  2.]

-----
### @numpy @fun @函数 ==================================================================
## tolist()
把np数组转换python的普通数组
>[array([1, 2]), array([3, 4])]  ->  [[1, 2], [3, 4]]
[ 1.+1.j  3.+2.j]  ->  [(1+1j), (3+2j)]

## astype(dtype)
把np数组转换制定type
>x = np.array([1, 2, 2.5])
x.astype(int)
array([1, 2, 2])


## reshape()
`b = np.arange(24).reshape(2,3,4)`把`0~23`的一维数组改变为`2*3*4`的三维数组
>[[[ 0, 1, 2, 3],
[ 4, 5, 6, 7],
[ 8, 9,10,11]],
[[12, 13, 14, 15],
[16, 17, 18, 19],
[20, 21, 22, 23]]]


## resize()
`c = b.resize()`是自身转换
>b = [[ 0  1  2  3  4  5  6  7  8  9 10 11]
[12 13 14 15 16 17 18 19 20 21 22 23]]
c = None


## ravel(), flatten(),
`b.ravel()`把数组展平, `b.flatten()`功能相同。
不过,flatten函数会请求分配内存来保存结果, ravel函数只是返回数组的一个视图而 (view)
>[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]


## transpose()
`b.transpose()`线性代数的转置矩阵
>[[0 1 2]
 [3 4 5]]
==========
[[0 3]
 [1 4]
 [2 5]]

 -----
### @numpy @组合数组 ==================================================================
## 组合数组
> a = arange(9).reshape(3,3)
b = 2 * a
a: array([[0, 1, 2],
[3, 4, 5],
[6, 7, 8]])
b: array([[ 0, 2, 4],
[ 6, 8, 10],
[12, 14,16]])


### 水平组合
`c = np.hstack((a,b))`, **注意**这里是`((a,b))`
>[[ 0  1  2  0  2  4]
 [ 3  4  5  6  8 10]
 [ 6  7  8 12 14 16]]

### 垂直组合
`c = np.vstack((a,b))`, **注意**这里是`((a,b))`
>[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 0  2  4]
 [ 6  8 10]
 [12 14 16]]

### 深度组合
`c = np.dstack((a,b))`, **注意**这里是`((a,b))`
深度组合,就是将一系列数组沿着纵轴(深度)方向进行层叠组合。
举个例子,有若干张二维平面内的图像点阵数据,我们可以将这些图像数据沿纵轴方向层叠在一起
>[[[ 0  0]
  [ 1  2]
  [ 2  4]],
 [[ 3  6]
  [ 4  8]
  [ 5 10]],
 [[ 6 12]
  [ 7 14]
  [ 8 16]]]

### 列组合
`c = np.column_stack((a,b))`, **注意**这里是`((a,b))`
对于二维数组,column_stack与hstack的效果是相同的
>a = np.array([0, 1])
b = np.array([2, 3])
c = np.column_stack((a,b))
[[0 2]
 [1 3]]

### 行组合
`c = np.row_stack((a,b))`, **注意**这里是`((a,b))`
对于二维数组,row_stack与vstack的效果是相同的
>c = np.row_stack((a,b))
[[0 1]
 [2 3]]

### 连接
`c = np.concatenate((a,b))`, **注意**这里是`((a,b))`
>c = np.concatenate((a,b))
[0 1 2 3]

-----
### @numpy @分割数组 ==================================================================
## 分割数组
> a = arange(9).reshape(3,3)
a: array([[0, 1, 2],
[3, 4, 5],
[6, 7, 8]])

### 水平分割
`c = np.hsplit(a,3)` 同`np.split(a,3,axis=1)`
>[array([[0],
[3],
[6]]), array([[1],
[4],
[7]]), array([[2],
[5],
[8]])]

### 垂直分割
`c = np.vsplit(a,3)` 同`np.split(a,3,axis=0)`
>[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]




### savetxt loadtxt

```perl
i2 = np.eye(2)
# 制造一个单元矩阵
#[[ 1.  0.], [ 0.  1.]]
np.savetxt("eye.txt", i2, delimiter=',', header='item1,item2', fmt='%f')

#ds-fun03.csv
#"set","x","y"
#1,1,-32.5871466755279
#1,2,-27.6371709786717
#1,3,-4.22551857649502
data = np.loadtxt('ds-fun03.csv', delimiter=',', skiprows=1,
    dtype={'names': ('set', 'x', 'y'), 'formats': ('i', 'i', 'f')})
```

Further explanation of the `fmt` parameter `(%[flag]width[.precision]specifier)`
[numpy.savetxt](http://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html)

格式字符串以一个百分号开始。接下来是一个可选的标志字符`flags`:-表示结果左对齐,0表示
左端补0,+表示输出符号(正号+或负号-)
。第三部分为可选的输出宽度参数`width`,表示输出的最小
位数。第四部分是精度格式符`precision`,以"."开头,后面跟一个表示精度的整数。最后是一个类型指定字
符`specifiers`,在我们的例子中指定为字符串类型。

    * c 单个字符
    * d或i 十进制有符号整数
    * e或E 科学记数法表示的浮点数
    * f 浮点数
    * g或G 自动在e、E和f中选择合适的表示法
    * o 八进制有符号整数
    * s 字符串
    * u 十进制无符号整数
    * x或X 十六进制无符号整数


### @numpy @fun @函数 @基本函数 ==================================================================
### 平均值 average() 这个是加权平均, mean()是算数平均

```perl
x = np.arange(6).reshape((3,2))
#[[0 1]
# [2 3]
# [4 5]]
y = np.average(x, axis=0)
#[ 2.  3.]
y = np.average(x, axis=1)
#[ 0.5  2.5  4.5]
y = np.average(x, axis=1, weights=[1./4, 3./4])
#[ 0.75  2.75  4.75]
x = np.arange(6)
#[0 1 2 3 4 5]
y = np.mean(x)
#2.5
```


### 最大,最小                                  `np.max(h), np.min(l)`
### 取值范围, 等于max(array) - min(array)       `np.ptp(h)`
### 取中位数, **注意**对于奇数个数组是对的, 偶数个数组为中间两个的平均值    `np.median(x)`
>x = np.array([1,6,4,9,2])
[1 6 4 9 2]
y = np.median(x)
4.0
x = np.array([1,6,4,9,2,5])
[1 6 4 9 2 5]
y = np.median(x)
4.5

### 方差`np.var()`, 标准差`np.std()`
>x = np.arange(5)
[0 1 2 3 4]
y = np.var(x)
2.0
y = np.std(x)
1.41421356237

### 排序, `axis`为负:表示从大到小                `x.sort(axis=-1), msort(x)`
>x = np.array([1,6,4,9,2])
y = np.msort(x)
x.sort()
